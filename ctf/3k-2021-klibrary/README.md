# Klibrary

Exploit linux kernel use after free with a race condition.

## Information

> Store your books safely inside the kernel!

> nc klibrary.2021.3k.ctf.to 9994

## Setup

This is a linux kernel pwn challenge. We have:

1. `bzImage` -> This is the linux kernel image
2. `initramfs.cpio` -> This is the compressed file system
3. `src/library.c` -> This is the source code of the custom kernel module
4. `start.sh` -> This is the qemu script to run the kernel image

To extract the filesystem use:

```sh
mkdir initramfs
cd initramfs
cpio -i < ../initramfs.cpio
```

Inside we can find the `init` file and the custom kernel module `library.ko`.

To compress the filesystem with cpio:

```sh
cd ./initramfs
find . | cpio -o -H newc > ../initramfs1.cpio
cd ../
```

To start the os as root you need to edit `initramfs/init`:

```
setsid cttyhack setuidgid 0 sh
# setsid cttyhack setuidgid 1000 sh
```

I modified the `start.sh` to compile my exploit, compress the filesystem, disable kaslr
and start qemu in debug mode:

```sh
#!/bin/sh

gcc -g -static ./exploit.c -o ./initramfs/exploit -lpthread -no-pie

cd ./initramfs
find . | cpio -o -H newc > ../initramfs1.cpio
cd ../

exec qemu-system-x86_64 \
    -m 128M \
    -nographic \
    -kernel "./bzImage" \
    -append "console=ttyS0 loglevel=3 oops=panic panic=-1 pti=on nokaslr" \
    -no-reboot \
    -cpu qemu64,+smep,+smap \
    -monitor /dev/null \
    -initrd "./initramfs1.cpio" \
    -smp 2 \
    -smp cores=2 \
    -smp threads=1 \
    -s
```

The active kernel protections are:

1. KASLR
3. SMEP -> You can't execute shellcode in user-space when the cpu is in kernel mode/ring 0
2. SMAP -> You can't access page in user-space when the cpu is in kernel mode (it's harder to rop)
3. KPTI -> Separate kernel-space from user-space page tables

## Analysis

`library.c`:

```c
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/mutex.h>
#include <linux/slab.h>
#include <linux/module.h>
#include <linux/uaccess.h>
#include <linux/device.h>

#define DEVICE_NAME "library"
#define CLASS_NAME "library"
#define BOOK_DESCRIPTION_SIZE 0x300

#define CMD_ADD			0x3000
#define CMD_REMOVE		0x3001
#define CMD_REMOVE_ALL	0x3002
#define CMD_ADD_DESC	0x3003
#define CMD_GET_DESC 	0x3004

static DEFINE_MUTEX(ioctl_lock);
static DEFINE_MUTEX(remove_all_lock);

MODULE_AUTHOR("MaherAzzouzi");
MODULE_DESCRIPTION("A library implemented inside the kernel.");
MODULE_LICENSE("GPL");

static int major;
static long library_ioctl(struct file* file, unsigned int cmd, unsigned long arg);
static int library_open(struct inode* inode, struct file *filp); 
static int library_release(struct inode* inode, struct file *filp); 

static struct file_operations library_fops = {
	.owner = 			THIS_MODULE,
	.unlocked_ioctl = 	library_ioctl,
	.open = 			library_open,
	.release = 			library_release
};

static struct class* library_class = NULL;
static struct device* library_device = NULL;

struct Book {
	char book_description[BOOK_DESCRIPTION_SIZE];
	unsigned long index;
	struct Book* next;
	struct Book* prev;
} *root;

struct Request {
	unsigned long index;
	char __user * userland_pointer;
};

unsigned long counter = 1;

static int add_book(unsigned long index);
static int remove_book(unsigned long index);
static noinline int remove_all(void);
static int add_description_to_book(struct Request request);
static int get_book_description(struct Request request);

static int library_open(struct inode* inode, struct file *filp) {
	
	printk(KERN_INFO "[library] : manage your books safely here!\n");
	return 0;
}


static int library_release(struct inode* inode, struct file *filp) {
	printk(KERN_INFO "[library] : vulnerable device closed! try harder.\n");
	remove_all();
	return 0;
}

static long library_ioctl(struct file* file, unsigned int cmd, unsigned long arg) {
	struct Request request;
	
	if(copy_from_user((void*)&request, (void*)arg, sizeof(struct Request))) {
		return -1;
	}
		
	if(cmd == CMD_REMOVE_ALL) {
		mutex_lock(&remove_all_lock);
		remove_all();
		mutex_unlock(&remove_all_lock);	
	} else {
		mutex_lock(&ioctl_lock);

		switch(cmd) {
				case CMD_ADD:
						add_book(request.index);
						break;
				case CMD_REMOVE:
						remove_book(request.index);
						break;
				case CMD_ADD_DESC:
						add_description_to_book(request);
						break;
				case CMD_GET_DESC:
						get_book_description(request);
						break;
		}

		mutex_unlock(&ioctl_lock);
	}
	return 0;

}

static int add_book(unsigned long index) {
	
	if(counter >= 10) {
		printk(KERN_INFO "[library] can only hold 10 books here\n");
		return -1;
	}

	struct Book *b, *p;
	b = (struct Book*)kzalloc(sizeof(struct Book), GFP_KERNEL);
	
	if(b == NULL) {
		printk(KERN_INFO "[library] : allocation failed! \n");
		return -1;
	}

	b->index = index;
	if(root == NULL) {
		root = b;
		root->prev = NULL;
		root->next = NULL;
	} else {
		p = root;
		while(p->next != NULL)
			p = p->next;
		p->next = b;
		b->prev = p;
		b->next = NULL;
	}

	counter++;

	return 0;
}

static int remove_book(unsigned long index) {
	struct Book *p, *prev, *next;
	if(root == NULL) {
		printk(KERN_INFO "[library] : no books in the library yet.");
		return -1;
	} 
	else if (root->index == index) {
		p = root;
		root = root->next;
		kfree(p);
	}
	else {
		p = root;
		while(p != NULL && p->index != index)
			p = p->next;
		
		if(p == NULL) {
			printk(KERN_INFO "[library] : can't remove %ld reason : not found\n", index);
		}

		prev = p->prev;
		next = p->next;
		prev->next = next;
		next->prev = prev;
		
		kfree(p);
	}

	counter--;

	return 0;
}

static noinline int remove_all(void) {
	struct Book *b, *p;
	b = root;
	
	while(b != NULL) {
		p = b->next;
		kfree(b);
		b = p;
	}
	
	root = NULL;
	counter = 1;
	return 0;
}

static int add_description_to_book(struct Request request) {
	struct Book* book = root;

	if(book == NULL){
		printk(KERN_INFO "[library] : no books in the library yet.\n");
		return -1;
	}
	

	for(; book != NULL && book->index != request.index; book = book->next);

	if(book == NULL) {
		printk(KERN_INFO "[library] : the given index wasn't found\n");
		return -1;
	}

	if(copy_from_user((void*)book->book_description,
					  (void*)(request.userland_pointer),
					  BOOK_DESCRIPTION_SIZE)) {
		printk(KERN_INFO "[library] : copy_from_user failed for some reason.\n");
		return -1;
	}
}

static int get_book_description(struct Request request) {
	struct Book* book;
	book = root;

	if(book == NULL) {
		printk("[library] : no books yet, can not read the description.\n");
		return -1;
	}

	while(book != NULL && book->index != request.index)
		book = book->next;

	if(book == NULL) {
		printk(KERN_INFO "[library] : no book with the index you provided\n");
		return -1;
	}

	if(copy_to_user((void*)request.userland_pointer,
					(void*)book->book_description,
					BOOK_DESCRIPTION_SIZE)) {
		printk("[library] : copy_to_user failed!\n");
		return -1;
	}
}

static int __init init_library(void) {
	major = register_chrdev(0, DEVICE_NAME, &library_fops);

	if(major < 0) {
		return -1;
	}

	library_class = class_create(THIS_MODULE, CLASS_NAME);
	if(IS_ERR(library_class)) {
		unregister_chrdev(major, DEVICE_NAME);
		return -1;
	}

	library_device = device_create(library_class, 
					0, 
					MKDEV(major, 0),
				   	0, 
					DEVICE_NAME);

	if(IS_ERR(library_device)) {
		class_destroy(library_class);
		unregister_chrdev(major, DEVICE_NAME);
		return -1;
	}

	root = NULL;
	mutex_init(&ioctl_lock);
	mutex_init(&remove_all_lock);
	printk(KERN_INFO "[library] : started!\n");
	return 0;
}

static void __exit exit_library(void) {
	
	device_destroy(library_class, MKDEV(major, 0));
	class_unregister(library_class);
	class_destroy(library_class);
	unregister_chrdev(major, DEVICE_NAME);

	mutex_destroy(&ioctl_lock);
	mutex_destroy(&remove_all_lock);
	printk(KERN_INFO "[library] : finished!\n");
}

module_init(init_library);
module_exit(exit_library);
```

To communicate with the kernel module we need to use [ioctl](https://man7.org/linux/man-pages/man2/ioctl.2.html).
The module has a double linked list called root:

```c
struct Book {
	char book_description[BOOK_DESCRIPTION_SIZE];
	unsigned long index;
	struct Book* next;
	struct Book* prev;
} *root;
```

We can interact with the module with 5 commands:

1. **CMD_ADD(index)** -> add book to the list and set the specified index
2. **CMD_REMOVE(index)** -> remove book from the list
3. **CMD_ADD_DESC(index, buffer)** -> copy userspace buffer inside `book_description`
4. **CMD_GET_DESC(index, buffer)** -> copy to userspace buffer the content of `book_description`
5. **CMD_REMOVE_ALL()** -> kfree all the book

We can have 10 books inside the list.

### Vulnerability

```c
if(cmd == CMD_REMOVE_ALL) {
    mutex_lock(&remove_all_lock);
    remove_all();
    mutex_unlock(&remove_all_lock);	
} else {
    mutex_lock(&ioctl_lock);

    switch(cmd) {
            case CMD_ADD:
                    add_book(request.index);
                    break;
            case CMD_REMOVE:
                    remove_book(request.index);
                    break;
            case CMD_ADD_DESC:
                    add_description_to_book(request);
                    break;
            case CMD_GET_DESC:
                    get_book_description(request);
                    break;
    }

    mutex_unlock(&ioctl_lock);
}
```

The vulnerability is easy to spot if you're familiar with this kind of challenge.
The module uses two separate `mutex_lock` to handle commands, so we can trigger a race condition:

1. one thread **add** the description and another does the kfree of the list -> Use-After-Free (write)
2. one thread **get** the description and another does the kfree of the list -> Use-After-Free (read)

### SLUB Intro

SLUB is the default allocator of the linux kernel, of course it's not easy to
understand the inner workings but there are some nice introductions on the internet:

1. https://github.com/PaoloMonti42/salt/blob/master/docs/0x00_SLUB_refresher.md
2. https://ruffell.nz/programming/writeups/2019/02/15/looking-at-kmalloc-and-the-slub-memory-allocator.html
3. https://hammertux.github.io/slab-allocator
4. Read the source code ðŸ˜Ž

To make things simple there are different freelist of free objects of different sizes
and there are specific list to contain only specifc objects (ex. task_struct of every process).
You can find the freelist with: `cat /proc/slabinfo`
The freelist are simple linked-list with the next pointer that points to next free object.
On the implementation of SLUB there are two protections that luckily for us weren't
enabled on this challenge(in reality only one would have been a bit tedious):

1. [CONFIG_SLAB_FREELIST_HARDENED](https://elixir.bootlin.com/linux/v5.11/source/mm/slub.c#L250) -> encrypt the next pointer with: xor of a random value xor address of the pointer bswapped (swap endianess, in a way similar to glibc 2.32 ptr protection)
2. [CONFIG_SLAB_FREELIST_RANDOM](https://elixir.bootlin.com/linux/v5.11/source/mm/slub.c#L1625) -> randomize the order of the freelist, by default the freed objects available are "ordered" from the lowest to highest address

Since our book struct occupies 0x318=792 bytes the kernel will get a freed object from a kmalloc-1024 list.

### Race condition

Spawning two threads that tries to trigger the race condition it's not optimal,
we have low probability of success. Luckily for us exists [userfaultfd](https://man7.org/linux/man-pages/man2/userfaultfd.2.html)
that can be used to register the routine to handle a page fault in userspace:

https://blog.lizzie.io/using-userfaultfd.html

